-- Export the trained model coefficients for JavaScript implementation
-- This query extracts the model weights and creates a JavaScript function

WITH model_info AS (
  SELECT
    processed_input AS feature_name,
    weight
  FROM
    ML.FEATURE_INFO(MODEL `helix-225321.pii_detection.url_segment_classifier`)
),
intercept AS (
  SELECT
    weight AS intercept_value
  FROM
    model_info
  WHERE
    feature_name = '__INTERCEPT__'
),
features AS (
  SELECT
    feature_name,
    weight
  FROM
    model_info
  WHERE
    feature_name != '__INTERCEPT__'
)
SELECT
  -- Generate JavaScript code for the model
  CONCAT(
    '// PII Detection Model - Logistic Regression\n',
    '// Generated from BigQuery ML model: helix-225321.pii_detection.url_segment_classifier\n',
    '// Generated on: ', CURRENT_TIMESTAMP(), '\n\n',
    
    '// Model coefficients\n',
    'const MODEL_INTERCEPT = ', CAST(intercept_value AS STRING), ';\n\n',
    
    'const MODEL_WEIGHTS = {\n',
    STRING_AGG(
      CONCAT('  "', feature_name, '": ', CAST(weight AS STRING)),
      ',\n'
      ORDER BY ABS(weight) DESC
    ),
    '\n};\n\n',
    
    '// Feature extraction functions (same as BigQuery UDFs)\n',
    'function calculateEntropy(str) {\n',
    '  if (!str || str.length === 0) return 0;\n',
    '  \n',
    '  const freq = {};\n',
    '  for (let char of str) {\n',
    '    freq[char] = (freq[char] || 0) + 1;\n',
    '  }\n',
    '  \n',
    '  let entropy = 0;\n',
    '  const len = str.length;\n',
    '  for (let char in freq) {\n',
    '    const p = freq[char] / len;\n',
    '    entropy -= p * Math.log2(p);\n',
    '  }\n',
    '  \n',
    '  return entropy;\n',
    '}\n\n',
    
    'function calculateIndexOfCoincidence(str) {\n',
    '  if (!str || str.length <= 1) return 0;\n',
    '  \n',
    '  const freq = {};\n',
    '  let total = 0;\n',
    '  for (let char of str.toLowerCase()) {\n',
    '    freq[char] = (freq[char] || 0) + 1;\n',
    '    total++;\n',
    '  }\n',
    '  \n',
    '  let sum = 0;\n',
    '  for (let char in freq) {\n',
    '    const count = freq[char];\n',
    '    sum += count * (count - 1);\n',
    '  }\n',
    '  \n',
    '  const n = total;\n',
    '  const ioc = sum / (n * (n - 1));\n',
    '  \n',
    '  return Math.min(ioc / 0.067, 1.0);\n',
    '}\n\n',
    
    'function getCharacterRatios(str) {\n',
    '  if (!str || str.length === 0) {\n',
    '    return {\n',
    '      letter_ratio: 0,\n',
    '      digit_ratio: 0,\n',
    '      special_ratio: 0,\n',
    '      uppercase_ratio: 0,\n',
    '      vowel_ratio: 0\n',
    '    };\n',
    '  }\n',
    '  \n',
    '  let letters = 0, digits = 0, special = 0, uppercase = 0, vowels = 0;\n',
    '  const vowelSet = new Set(["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]);\n',
    '  \n',
    '  for (let char of str) {\n',
    '    if (/[a-zA-Z]/.test(char)) {\n',
    '      letters++;\n',
    '      if (/[A-Z]/.test(char)) uppercase++;\n',
    '      if (vowelSet.has(char)) vowels++;\n',
    '    } else if (/[0-9]/.test(char)) {\n',
    '      digits++;\n',
    '    } else {\n',
    '      special++;\n',
    '    }\n',
    '  }\n',
    '  \n',
    '  const len = str.length;\n',
    '  return {\n',
    '    letter_ratio: letters / len,\n',
    '    digit_ratio: digits / len,\n',
    '    special_ratio: special / len,\n',
    '    uppercase_ratio: letters > 0 ? uppercase / letters : 0,\n',
    '    vowel_ratio: letters > 0 ? vowels / letters : 0\n',
    '  };\n',
    '}\n\n',
    
    'function getNumberPositions(str) {\n',
    '  if (!str || str.length === 0) {\n',
    '    return {\n',
    '      has_number_start: false,\n',
    '      has_number_middle: false,\n',
    '      has_number_end: false,\n',
    '      consecutive_digits_max: 0\n',
    '    };\n',
    '  }\n',
    '  \n',
    '  const has_number_start = /^[0-9]/.test(str);\n',
    '  const has_number_end = /[0-9]$/.test(str);\n',
    '  const has_number_middle = /[^0-9][0-9][^0-9]/.test(str);\n',
    '  \n',
    '  let maxConsecutive = 0;\n',
    '  let currentConsecutive = 0;\n',
    '  for (let char of str) {\n',
    '    if (/[0-9]/.test(char)) {\n',
    '      currentConsecutive++;\n',
    '      maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n',
    '    } else {\n',
    '      currentConsecutive = 0;\n',
    '    }\n',
    '  }\n',
    '  \n',
    '  return {\n',
    '    has_number_start,\n',
    '    has_number_middle,\n',
    '    has_number_end,\n',
    '    consecutive_digits_max: maxConsecutive\n',
    '  };\n',
    '}\n\n',
    
    'function getPatternFeatures(str) {\n',
    '  if (!str || str.length === 0) {\n',
    '    return {\n',
    '      has_uuid_pattern: false,\n',
    '      has_hex_pattern: false,\n',
    '      has_base64_pattern: false,\n',
    '      has_email_pattern: false,\n',
    '      segment_count: 0,\n',
    '      avg_segment_length: 0\n',
    '    };\n',
    '  }\n',
    '  \n',
    '  const has_uuid_pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(str);\n',
    '  \n',
    '  const hexChars = str.match(/[0-9a-f]/gi) || [];\n',
    '  const has_hex_pattern = hexChars.length / str.length > 0.8;\n',
    '  \n',
    '  const has_base64_pattern = /^[A-Za-z0-9+/_-]+={0,2}$/.test(str) && str.length % 4 === 0;\n',
    '  \n',
    '  const has_email_pattern = /@|%40/.test(str);\n',
    '  \n',
    '  const segments = str.split(/[-_.]/);\n',
    '  const segment_count = segments.length;\n',
    '  const avg_segment_length = segments.reduce((sum, seg) => sum + seg.length, 0) / segment_count;\n',
    '  \n',
    '  return {\n',
    '    has_uuid_pattern,\n',
    '    has_hex_pattern,\n',
    '    has_base64_pattern,\n',
    '    has_email_pattern,\n',
    '    segment_count,\n',
    '    avg_segment_length\n',
    '  };\n',
    '}\n\n',
    
    'function getBigramFeatures(str) {\n',
    '  if (!str || str.length < 2) {\n',
    '    return {\n',
    '      num_bigrams: 0,\n',
    '      digit_bigrams: 0,\n',
    '      letter_bigrams: 0,\n',
    '      mixed_bigrams: 0,\n',
    '      special_bigrams: 0\n',
    '    };\n',
    '  }\n',
    '  \n',
    '  let normalized = "";\n',
    '  for (let char of str.toLowerCase()) {\n',
    '    if (/[a-z0-9]/.test(char)) {\n',
    '      normalized += char;\n',
    '    } else if (char === "-" || char === "_") {\n',
    '      normalized += char;\n',
    '    } else {\n',
    '      normalized += "%";\n',
    '    }\n',
    '  }\n',
    '  \n',
    '  let digit_bigrams = 0, letter_bigrams = 0, mixed_bigrams = 0, special_bigrams = 0;\n',
    '  \n',
    '  for (let i = 0; i < normalized.length - 1; i++) {\n',
    '    const char1 = normalized[i];\n',
    '    const char2 = normalized[i + 1];\n',
    '    \n',
    '    const isDigit1 = /[0-9]/.test(char1);\n',
    '    const isDigit2 = /[0-9]/.test(char2);\n',
    '    const isLetter1 = /[a-z]/.test(char1);\n',
    '    const isLetter2 = /[a-z]/.test(char2);\n',
    '    const isSpecial1 = !isDigit1 && !isLetter1;\n',
    '    const isSpecial2 = !isDigit2 && !isLetter2;\n',
    '    \n',
    '    if (isDigit1 && isDigit2) {\n',
    '      digit_bigrams++;\n',
    '    } else if (isLetter1 && isLetter2) {\n',
    '      letter_bigrams++;\n',
    '    } else if (isSpecial1 || isSpecial2) {\n',
    '      special_bigrams++;\n',
    '    } else {\n',
    '      mixed_bigrams++;\n',
    '    }\n',
    '  }\n',
    '  \n',
    '  return {\n',
    '    num_bigrams: normalized.length - 1,\n',
    '    digit_bigrams,\n',
    '    letter_bigrams,\n',
    '    mixed_bigrams,\n',
    '    special_bigrams\n',
    '  };\n',
    '}\n\n',
    
    '// Extract all features for a URL segment\n',
    'function extractFeatures(segment) {\n',
    '  const charRatios = getCharacterRatios(segment);\n',
    '  const numberPos = getNumberPositions(segment);\n',
    '  const patterns = getPatternFeatures(segment);\n',
    '  const bigrams = getBigramFeatures(segment);\n',
    '  \n',
    '  const features = {\n',
    '    length: segment.length,\n',
    '    entropy: calculateEntropy(segment),\n',
    '    ioc: calculateIndexOfCoincidence(segment),\n',
    '    letter_ratio: charRatios.letter_ratio,\n',
    '    digit_ratio: charRatios.digit_ratio,\n',
    '    special_ratio: charRatios.special_ratio,\n',
    '    uppercase_ratio: charRatios.uppercase_ratio,\n',
    '    vowel_ratio: charRatios.vowel_ratio,\n',
    '    has_number_start: numberPos.has_number_start ? 1 : 0,\n',
    '    has_number_middle: numberPos.has_number_middle ? 1 : 0,\n',
    '    has_number_end: numberPos.has_number_end ? 1 : 0,\n',
    '    consecutive_digits_max: numberPos.consecutive_digits_max,\n',
    '    has_uuid_pattern: patterns.has_uuid_pattern ? 1 : 0,\n',
    '    has_hex_pattern: patterns.has_hex_pattern ? 1 : 0,\n',
    '    has_base64_pattern: patterns.has_base64_pattern ? 1 : 0,\n',
    '    has_email_pattern: patterns.has_email_pattern ? 1 : 0,\n',
    '    segment_count: patterns.segment_count,\n',
    '    avg_segment_length: patterns.avg_segment_length,\n',
    '    num_bigrams: bigrams.num_bigrams,\n',
    '    digit_bigrams: bigrams.digit_bigrams,\n',
    '    letter_bigrams: bigrams.letter_bigrams,\n',
    '    mixed_bigrams: bigrams.mixed_bigrams,\n',
    '    special_bigrams: bigrams.special_bigrams\n',
    '  };\n',
    '  \n',
    '  // Add derived features\n',
    '  features.digit_bigram_ratio = features.num_bigrams > 0 ? features.digit_bigrams / features.num_bigrams : 0;\n',
    '  features.letter_bigram_ratio = features.num_bigrams > 0 ? features.letter_bigrams / features.num_bigrams : 0;\n',
    '  features.mixed_bigram_ratio = features.num_bigrams > 0 ? features.mixed_bigrams / features.num_bigrams : 0;\n',
    '  features.special_bigram_ratio = features.num_bigrams > 0 ? features.special_bigrams / features.num_bigrams : 0;\n',
    '  features.normalized_entropy = features.length > 0 ? features.entropy / Math.log2(features.length) : 0;\n',
    '  features.complexity_score = (\n',
    '    features.entropy * 0.3 +\n',
    '    features.digit_ratio * 0.2 +\n',
    '    (1 - features.letter_ratio) * 0.2 +\n',
    '    (features.consecutive_digits_max > 3 ? 0.3 : 0)\n',
    '  );\n',
    '  \n',
    '  return features;\n',
    '}\n\n',
    
    '// Predict whether a URL segment contains PII\n',
    'function predictPII(segment) {\n',
    '  const features = extractFeatures(segment);\n',
    '  \n',
    '  // Calculate linear combination\n',
    '  let z = MODEL_INTERCEPT;\n',
    '  \n',
    '  for (const [feature, value] of Object.entries(features)) {\n',
    '    if (MODEL_WEIGHTS[feature]) {\n',
    '      z += MODEL_WEIGHTS[feature] * value;\n',
    '    }\n',
    '  }\n',
    '  \n',
    '  // Apply sigmoid function for probability\n',
    '  const probability = 1 / (1 + Math.exp(-z));\n',
    '  \n',
    '  return {\n',
    '    isPII: probability > 0.5,\n',
    '    probability: probability,\n',
    '    features: features\n',
    '  };\n',
    '}\n\n',
    
    '// Export for use in Edge Workers\n',
    'if (typeof module !== "undefined" && module.exports) {\n',
    '  module.exports = { predictPII, extractFeatures };\n',
    '}\n'
  ) AS javascript_model
FROM
  intercept
CROSS JOIN
  (SELECT STRING_AGG(
    CONCAT('  "', feature_name, '": ', CAST(weight AS STRING)),
    ',\n'
    ORDER BY ABS(weight) DESC
  ) AS weights_string FROM features);